---
description: 認可とアクセス制御（RBAC/ABAC/ReBAC、IDOR、マスアサインメント、トランザクション認可）
languages:
- c
- go
- java
- javascript
- php
- python
- ruby
- typescript
- yaml
alwaysApply: false
---

## 認可とアクセス制御

すべてのリクエストとリソースに対して最小権限と正確なアクセス決定を強制し、IDORとマスアサインメントを防止し、必要に応じて強力なトランザクション認可を提供します。

### 基本原則
1.  デフォルトで拒否：任意のアクセスリクエストのデフォルトは「拒否」とします。明示的に拒否するのではなく、ロールまたはユーザーに権限を明示的に付与します。許可ルールが一致しない場合、HTTP 403 Forbiddenを返します。
2.  最小権限の原則：ユーザーには職務を遂行するために必要な最小限のアクセスレベルを付与します。権限が過剰でないことを確認するため、定期的に監査します。
3.  すべてのリクエストで権限を検証：ソースに関係なく（AJAX、API、直接）、すべてのリクエストで認可をチェックします。ミドルウェア/フィルターを使用して一貫した強制を確保します。
4.  RBACよりABAC/ReBACを優先：シンプルなロールベースアクセス制御の代わりに、属性ベースアクセス制御（ABAC）または関係ベースアクセス制御（ReBAC）を使用して詳細な権限を実現します。

### システム制御
- サービス境界でミドルウェア/ポリシー/フィルターを介して認可を集中化。
- リソースレベルで権限をモデル化（所有権/テナンシー）し、データクエリでスコーピングを強制。
- リソースの存在を漏らさないよう、汎用的な403/404レスポンスを返す。
- ユーザー、アクション、リソース識別子（非PII）、理由コードですべての拒否をログ。

### IDORの防止
- ユーザー提供の識別子を単独で信頼しない。常に各オブジェクトインスタンスへのアクセスを検証。
- ユーザースコープのクエリまたはサーバーサイドルックアップを通じてリソースを解決。例：`Project.find(id)`の代わりに`currentUser.projects.find(id)`。
- 防御の深層として、列挙不可能な識別子（UUID/ランダム）を使用。曖昧さのみに依存しない。

### マスアサインメントの防止
- リクエストボディを機密フィールドを含むドメインオブジェクトに直接バインドしない。
- DTOを介して安全で編集可能なフィールドのみを公開。パッチ/更新用の明示的な許可リストを維持。
- 許可リストが実現不可能な場合、フレームワーク機能を使用して機密フィールドをブロックリスト化。

### トランザクション認可（ステップアップ）
- 機密性の高いアクション（送金、権限昇格、データエクスポート）には第2要素を要求。What-You-See-Is-What-You-Signを適用：ユーザー確認のため重要フィールドを表示。
- トランザクションごとに一意で時間制限された認可資格情報を使用；フロー途中でのデータ変更時には拒否。
- 選択した認可方式をサーバーサイドで強制；クライアントサイドのダウングレードを防止。
- スロットリングと失敗後の完全なフロー再開で、ブルートフォース攻撃から保護。

### テストと自動化
- エンドポイント/リソース、ロール/属性、期待される結果をリストした認可マトリックス（YAML/JSON）を維持。
- マトリックスを反復処理し、ロールトークンを生成し、許可/拒否結果（トークン有効期限/取り消しケースを含む）を検証する統合テストを自動化。
- ネガティブテストを実施：IDの交換、ロールのダウングレード、スコープの欠落、バイパス試行。

### 実装チェックリスト
- ミドルウェア/ポリシーがデフォルト拒否とすべてのエンドポイントでのリソースチェックを強制。
- クエリスコーピングにより、ユーザーが許可された行/オブジェクトのみにアクセスできることを保証。
- DTOと許可リストでマスアサインメントを防止；機密フィールドは決してバインド不可。
- 一意で短命の資格情報を用いた機密操作のステップアップ認可を実施。
- 認可マトリックスがCIテストを駆動；失敗はマージをブロック。
