---
description: 暗号化ストレージベストプラクティス
languages:
- c
- go
- java
- javascript
- kotlin
- matlab
- python
- ruby
- swift
- typescript
alwaysApply: false
---

## はじめに

このルールは、保存データを保護するソリューションを実装する際に従うべきシンプルなモデルを提供します。

パスワードは可逆暗号化を使用して保存すべきではありません - 代わりにセキュアなパスワードハッシュアルゴリズムを使用する必要があります。[Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)には、パスワード保存に関する詳細なガイダンスが含まれています。

## ルール1: アーキテクチャ設計要件

**システムの全体的なアーキテクチャを検討する必要があります** - これは技術実装に大きな影響を与えます。

* **アプリケーションレベル** - データベース侵害保護に必須
* **データベースレベル**（SQL Server TDE）- 追加の保存時データ保護
* **ファイルシステムレベル**（BitLocker、LUKS）- 物理的盗難保護
* **ハードウェアレベル**（暗号化RAID/SSD）- ハードウェアベース保護

**機密データの保存を最小化する必要があります** - クレジットカード詳細の保存を避け、データ最小化ポリシーを実装します。保存が避けられない場合はトークン化を使用します。

## ルール2: アルゴリズム要件

**承認されたアルゴリズムを使用する必要があります：**
* **対称暗号：** 128ビット以上の鍵を持つAES（256ビット推奨）
* **非対称暗号：** Curve25519（ECC推奨）またはRSA 2048ビット以上
* **カスタムアルゴリズム：** 禁止

**認証付き暗号モードを使用する必要があります：**
1. **GCM**または**CCM**（推奨）
2. **CTR/CBC**は別途認証を伴う場合のみ（Encrypt-then-MAC）
3. **ECB：** 禁止

**RSAの場合：ランダムパディングを有効化する必要があります**（OAEP/PKCS#1）。

**暗号学的に安全な乱数生成器を使用する必要があります：**

| プラットフォーム | 禁止 | 必須 |
|----------|------------|----------|
| PHP | `rand()`, `mt_rand()` | `random_bytes()`, `random_int()` |
| Java | `java.util.Random` | `java.security.SecureRandom` |
| .NET | `System.Random` | `System.Security.Cryptography.RandomNumberGenerator` |
| Python | `random`モジュール | `secrets`モジュール |
| JavaScript | `Math.random()` | `window.crypto.getRandomValues()` |
| Go | `math/rand` | `crypto/rand` |
| Node.js | `Math.random()` | `crypto.randomBytes()`, `crypto.randomInt()` |

**UUID：** バージョン1のUUIDはランダムではありません。実装がCSPRNGを使用している場合のみ、バージョン4のUUIDを信頼してください。

## ルール3: 鍵管理要件

**以下のための正式なプロセスを実装する必要があります：**
* 暗号学的に安全な関数を使用した鍵生成
* セキュアな鍵配布とデプロイ
* 定期的な鍵ローテーションとセキュアな廃止

**鍵生成：** パスワード、フレーズ、予測可能なパターンの使用は禁止されています。複数の鍵は完全に独立している必要があります。

**鍵ローテーション要件 - 以下の場合に鍵をローテーションする必要があります：**
* 鍵の侵害が疑われる場合
* 暗号期間が満了した場合（NIST SP 800-57を参照）
* 使用制限に達した場合（64ビット鍵で2^35バイト、128ビット鍵で2^68バイト）
* アルゴリズムのセキュリティが変更された場合

**侵害前にローテーションプロセスを準備しておく必要があります。**

## ルール4: 鍵保存要件

**利用可能な場合、セキュアなストレージメカニズムを使用する必要があります：**
* 物理/仮想HSM
* クラウド鍵ボルト（AWS KMS、Azure Key Vault、Google Cloud KMS）
* 外部シークレット管理（HashiCorp Vault、Conjur）
* フレームワークのセキュアAPI（ProtectedData、Keychain）

**基本的なストレージルール（セキュアなメカニズムが利用できない場合）：**
* 禁止：ソースコードまたはバージョン管理への鍵のハードコーディング
* 必須：設定ファイルへの制限的な権限
* 回避：環境変数（露出リスク）

**鍵の分離：** 可能な限り、暗号化されたデータとは別に鍵を保存する必要があります。

**鍵の暗号化：** 別個の鍵暗号化鍵（KEK）を使用して保存された鍵を暗号化する必要があります：
* データ暗号化鍵（DEK）がデータを暗号化
* 鍵暗号化鍵（KEK）がDEKを暗号化
* KEKは別に保存され、DEKと同等以上の強度である必要があります

## ルール5: 多層防御要件

**暗号化制御が失敗した場合でもアプリケーションがセキュアであるように設計する必要があります：**
* 暗号化情報のための追加のセキュリティ層
* 強力なアクセス制御（暗号化されたURLパラメータのみに依存しない）
* 暗号化データアクセスのロギングと監視

## 重要なセキュリティ要件

機密データを扱うすべてのシステムで**コンプライアンスは必須**です。

**以下は絶対に禁止されています：**
* カスタム暗号化アルゴリズムの実装
* セキュリティ目的での安全でない乱数生成器の使用
* ソースコードへの暗号化鍵のハードコーディング
* 非推奨のアルゴリズムの使用（MD5、SHA-1、DES、RC4）
* 適切な分離なしでの暗号化データと鍵の保存

**常に以下を行う必要があります：**
* 利用可能な場合、認証付き暗号化モードを使用
* 各操作に対してユニークでランダムな鍵を生成
* 適切な鍵ライフサイクル管理を実装
* 検証済みの暗号化ライブラリのみを使用
* 必要になる前に鍵ローテーション手順をテスト