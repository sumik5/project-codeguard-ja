---
description: 認証セキュリティのベストプラクティス
languages:
- c
- go
- java
- javascript
- php
- python
- ruby
- typescript
alwaysApply: false
---

安全な認証は、アプリケーション開発の最も重要な側面の1つです。

- ユーザーには内部的に非公開でランダム、一意な識別子を使用します。ログインには、確認済みメールアドレスまたはユーザー名の使用を許可しますが、攻撃者が有効なアカウントを推測できないよう、エラーメッセージは汎用的（例：「ユーザー名またはパスワードが無効です」）にします。
- 適切なパスワード強度管理を実装：最小8文字、パスフレーズをサポートするため最大64文字以上、Unicode文字と空白を含むすべての文字を許可、複雑さの規則を避ける（大文字/小文字/数字/特殊文字の要求なし）。
- HaveIBeenPwnedのPwned Passwords APIなどのサービスを使用して、一般的および過去に侵害されたパスワードをブロックし、ユーザーがより強力なパスワードを作成できるようパスワード強度メーターを含めます。
- Argon2（推奨）またはbcryptなどの最新の強力で低速なハッシュアルゴリズムを推奨パラメータで使用してユーザーパスワードを保存します。ユーザーごとに一意なソルトを使用します。
- パスワードマネージャーをサポート：標準の`<input type="password">`フィールドを使用し、パスワードマネージャーとの互換性を確保するため貼り付けを許可します。
- すべての場所でTLSを使用：認証情報、セッショントークン、または機密データを送信するすべての通信はHTTPS経由である必要があります。
- パスワードハッシュを比較する際は、タイミング攻撃を防ぐため、安全な定数時間比較関数を使用します。
- 自動攻撃から保護：ログイン試行失敗後のアカウントロックアウト、ブルートフォース攻撃を防ぐCAPTCHAの使用、認証エンドポイントでのレート制限を検討します。
- 機密性の高いアカウントにはTOTP（認証アプリ）またはWebAuthn（ハードウェアキー）を使用した多要素認証（MFA）を要求します。すべてのユーザーにMFAを必須にすることを検討します。
- 安全なセッション管理を実装：セッションCookieにはHttpOnlyとSecureフラグを使用、ログイン後にセッションIDをローテーション、適切なセッションタイムアウトを設定します。
- ユーザーがパスワードを変更する前に、現在のパスワードの再入力を要求します。すべての機密機能とトランザクション（パスワード変更、メール更新、金融取引）に再認証を要求します。
- アカウントの存在を明らかにしない安全なパスワード復旧メカニズムを実装（「そのメールアドレスがデータベースに存在する場合、パスワードをリセットするメールを送信します」）。
- 包括的なログと監視を有効化：セキュリティ監視とインシデント対応のため、すべての認証失敗、ログイン成功、アカウントロックアウト、パスワード変更をログに記録します。
- 内部または管理アカウントは、パブリックログインフォームからアクセス可能にしないでください。内部ユーザーには別の、より安全な認証システムを使用します。
- 委任またはフェデレーション認証には、OAuth 2.0、OpenID Connect（OIDC）、SAMLなどの確立されたプロトコルを使用します。独自に構築しないでください。
