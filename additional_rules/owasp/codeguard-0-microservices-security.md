---
description: マイクロサービスセキュリティベストプラクティス
languages:
- c
- go
- java
- javascript
- python
- ruby
- typescript
- yaml
alwaysApply: false
---

## マイクロサービスセキュリティガイドライン

マイクロサービスベースシステムにおける認証、認可、ロギングを実装するための必須セキュリティプラクティス。

### エッジレベル認可

APIゲートウェイは下流のマイクロサービスのために認可の実施を一元化できますが、制限があります：
- すべての認可決定をゲートウェイに押し込むと、複雑なエコシステムでは管理が困難になる
- APIゲートウェイが単一の決定ポイントになり、「多層防御」に違反する可能性
- 運用チームが通常ゲートウェイを所有するため、開発速度が低下

**推奨事項**: エッジレベル（粗粒度）とサービスレベル（細粒度）の両方で認可を実装。

### サービスレベル認可パターン

**NISTコンポーネント**:
- Policy Administration Point (PAP): アクセス制御ルールを作成・管理するためのユーザーインターフェース
- Policy Decision Point (PDP): アクセス制御ポリシーを評価してアクセス決定を計算
- Policy Enforcement Point (PEP): 保護されたオブジェクトのポリシー決定を実施
- Policy Information Point (PIP): ポリシー評価のための属性の取得元

#### 埋め込みPolicy Decision Pointを使用した集中パターン

**推奨アプローチ**: アクセス制御ルールは一元的に定義されるが、マイクロサービスレベルで保存・評価される。

1. PAPを使用してアクセス制御ルールを定義し、必要な属性とともに埋め込みPDPに配信
2. サブジェクトがマイクロサービスエンドポイントを呼び出すと、マイクロサービスコードがPDPを呼び出す
3. PDPは入力をルールと属性に対して評価してアクセス制御ポリシー決定を生成
4. マイクロサービスはPDP決定に基づいて認可を実施

**実装**: PDPはマイクロサービス組み込みライブラリまたはサービスメッシュアーキテクチャのサイドカーとして実装。

### 認可実装の推奨事項

1. ソースコードにハードコーディングする代わりに、特殊言語を使用してポリシーを表現
2. 専任のセキュリティチームが管理するプラットフォームレベルソリューションとして実装
3. カスタム実装ではなく広く採用されているソリューションを使用
4. 「多層防御」原則を実装：
   - ゲートウェイ/プロキシレベル: 粗粒度認可
   - マイクロサービスレベル: 共有認可コンポーネントを使用した細粒度決定
   - ビジネスコードレベル: ビジネス固有のアクセス制御ルール
5. アクセス制御ポリシーの開発、承認、展開のための正式な手順を実装

### 外部エンティティアイデンティティの伝播

**問題**: 内部サービスは細粒度認可決定のために呼び出し元のコンテキストが必要。

**アンチパターン**: 外部アクセストークンを内部で再利用（トークン漏洩リスクのため安全でない）。

#### 推奨パターン: 信頼できる発行者による署名されたデータ構造

エッジ認証後、外部エンティティアイデンティティ（ユーザーID、ロール、権限）を表すデータ構造を生成し、信頼できる発行者によって署名または暗号化され、内部マイクロサービスに伝播。

**実装の推奨事項**:
1. 外部アクセストークンと内部表現を分離
2. 外部エンティティアイデンティティを表現・伝播するために単一のデータ構造を使用
3. 内部エンティティ表現構造に署名（対称または非対称暗号化）
4. 追加のクレームのために内部構造を拡張可能にする
5. 信頼境界外に内部エンティティ表現構造を絶対に公開しない

### サービス間認証

#### 相互トランスポート層セキュリティ (mTLS)

各マイクロサービスは、mTLSを介した認証のために公開鍵/秘密鍵ペアを保持。以下を提供：
- 正規サービスの識別
- 送信データの機密性と完全性

**課題**: 鍵のプロビジョニング、信頼のブートストラップ、証明書の失効、鍵のローテーション。

#### トークンベース認証

トークンには呼び出し元ID（マイクロサービスID）と権限（スコープ）が含まれる。プロセス：
1. 呼び出し元マイクロサービスがサービスIDとパスワードを使用してセキュリティトークンサービスから署名済みトークンを取得
2. HTTPヘッダーを介して送信リクエストにトークンを添付
3. 呼び出されたマイクロサービスがオンラインまたはオフラインでトークンを抽出・検証

**オンライン検証**: 集中サービスへのネットワーク呼び出し（失効トークンを検出、高レイテンシ、重要なリクエスト向け）
**オフライン検証**: ダウンロードした公開鍵を使用（失効トークンを検出できない可能性、低レイテンシ、非重要リクエスト向け）

### ロギングアーキテクチャ

**原則**:
- 各マイクロサービスは標準出力を使用してローカルファイルにログメッセージを書き込む
- ロギングエージェントが定期的にログメッセージを取得しメッセージブローカーに公開
- 集中ロギングサービスがメッセージブローカーメッセージをサブスクライブ

**主要要件**:

1. **ローカルファイルロギング**: マイクロサービスは集中ロギングシステムに直接書き込まずローカルファイルに書き込む
2. **専用ロギングエージェント**: マイクロサービスと同じホストに展開された分離コンポーネント
3. **非同期パターン**: メッセージブローカーがロギングエージェントと集中サービス間の非同期接続を実装
4. **相互認証**: ロギングエージェントとメッセージブローカーは相互認証を使用（TLS）
5. **アクセス制御**: メッセージブローカーは最小権限でアクセス制御ポリシーを実施
6. **データサニタイゼーション**: ログメッセージをフィルタリング/サニタイズして機密データを除外（PII、パスワード、APIキー）
7. **相関ID**: すべての呼び出しチェーンに一意の相関IDを生成してログメッセージをグループ化
8. **ヘルスモニタリング**: ロギングエージェントがヘルスとステータスデータを提供
9. **構造化フォーマット**: ログメッセージを構造化フォーマット（JSON、CSV）で公開
10. **コンテキストデータ**: プラットフォームコンテキスト（ホスト名、コンテナ名）とランタイムコンテキスト（クラス名、ファイル名）を追加

### セキュリティアーキテクチャドキュメント

脅威モデリング、攻撃面分析、最小権限の実施をサポートするための必須ドキュメント：

#### サービスとインフラストラクチャインベントリ
- 一意のID、ビジネス機能、スコープやAPIキーを含むセキュリティスキームを含むAPI定義、ソースリポジトリ、チーム所有権を持つすべてのアプリケーションサービスとインフラストラクチャコンポーネントを文書化
- 認証、認可、ロギング、モニタリング、ディスカバリサービスを含める
- ソフトウェアタイプを持つデータストレージ（データベース、キャッシュ）とメッセージキューを文書化

#### データ分類とフローマッピング
- 保護レベル（PII、機密、公開）でデータ資産を識別・分類
- アクセスタイプ（読み取り、読み書き）を持つサービスとストレージの関係をマップ化
- 交換されるデータを含むサービス間通信（同期HTTP/gRPC、非同期メッセージング）を文書化
- どのアセットがどのシステムに保存されるかを追跡（ゴールデンソース vs キャッシュ）

#### アーキテクチャの視覚化
- サービス呼び出しグラフまたはデータフロー図を使用してグラフィカル表現を作成
- DOT言語などのツールを使用してコンポーネント関係と信頼境界を視覚化
- すべての接続とデータフローを示す最新のアーキテクチャ図を維持

#### セキュリティアプリケーション
このドキュメントにより以下が可能：
- API定義から攻撃面を列挙し、焦点を絞ったセキュリティテストを実施
- サービス境界を越えた機密データの移動を追跡してデータ漏洩分析を実施
- 文書化されたインタラクションに基づいて最小限の権限を定義して最小権限を実装
- 信頼境界の検証とすべてのサービス通信の正当化
- 重複または欠落した保護を避けるために集中セキュリティ制御を検証

### セキュリティベストプラクティスのまとめ

- 複数レイヤーで多層防御認可を実装
- 埋め込み決定ポイントを使用した集中ポリシー管理を使用
- 署名された内部アイデンティティトークンを伝播、外部トークンは絶対に伝播しない
- 可能な場合はサービス認証にmTLSを選択、柔軟性のためにトークンベースを選択
- 適切なデータサニタイゼーションを備えた耐障害性の高い安全なロギングを実装
- 脅威モデリングとセキュリティ分析のために包括的なアーキテクチャドキュメントを維持
- すべてのセキュリティポリシー変更に正式なガバナンス手順を適用
