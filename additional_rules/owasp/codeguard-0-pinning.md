---
description: 証明書と公開鍵ピンニングセキュリティ
languages:
- c
- java
- javascript
- kotlin
- matlab
- swift
- typescript
- xml
alwaysApply: false
---

## 証明書と公開鍵ピンニングガイドライン

敵対的な環境で中間者攻撃を防ぐための証明書と公開鍵ピンニングを実装するための重要なプラクティス。

### 問題の理解

TLSチャネルは、以下を通じて証明書ベースの信頼が侵害された場合、MITM攻撃に対して脆弱になる可能性があります：
1. 攻撃者が被害者サイトのために信頼されたCAから不正な証明書を取得
2. 攻撃者がクライアントのトラストストアに危険なCAを注入

ピンニングは、ホストをその期待されるX509証明書または公開鍵に関連付け、広告された認証情報が一致する必要があるピンセットを作成します。

### ピンニングすべきでない場合（重要な決定基準）

以下の状況ではピンニングを避けます：
- 接続のクライアントとサーバーの両側を制御していない
- アプリの再デプロイなしでピンセットを安全に更新できない
- サービスに投入される前に証明書キーペアを予測できない
- アプリケーションがネイティブモバイルアプリケーションでない
- ピンセットの更新が運用に支障をきたす

最新の認証局セキュリティの進歩を考えると、停止のリスクはセキュリティの利点をほぼ常に上回ります。

### ピンニングが適切な場合

以下の場合のみピンニングを検討：
- 両端点を制御し、証明書ライフサイクルを管理できる
- 安全なピン更新メカニズムを実装できる
- 脅威モデルがCA侵害に対する保護を特に必要とする
- 徹底的にテストし、証明書ローテーションの計画を立てた

### プラットフォーム別実装アプローチ

#### Android
Androidのネットワークセキュリティ設定機能を`<pin-set>`設定で使用します。または、プログラムによるピンニングのためにOkHTTPなどの確立されたライブラリを使用します。カスタムSSL検証をゼロから実装することは避けてください。

#### iOS
AppleはApp Transport Security Settings配下の`Info.plist`を介してCA公開鍵をピンニングすることを提案しています。より簡単な実装のためTrustKitライブラリを使用します。カスタム実装には、HTTPS Server Trust Evaluationガイドラインに従ったSecTrustEvaluateロジックが必要です。

#### .Net
証明書検証のためServicePointManagerコールバックを使用して実装します。

#### OpenSSL
verify_callbackまたはSSL_get_peer_certificateによる接続後検証を使用します。SSL_get_verify_result（X509_V_OKを検証）とSSL_get_peer_certificate（非NULLを検証）を呼び出す必要があります。検証エラー時に接続を失敗させ、ソケットを破棄します。

#### Electron
カスタム証明書検証のためelectron-ssl-pinningライブラリまたはses.setCertificateVerifyProcを使用します。

### ピンニングするもの

ピン選択戦略：
1. リーフ証明書ピンニング（推奨）：100%の確実性を提供しますが、証明書ローテーション中のアプリ破損を防ぐため中間CAのバックアップピンが必要
2. 中間CAピンニング：リスクを削減しますが、そのCAによって発行されたすべての証明書を信頼
3. ルートCAピンニング：すべての中間CAを信頼する高リスクのため推奨されません

ピンタイプオプション：
- 証明書全体：実装が最も簡単だが、証明書ローテーションのため頻繁な更新が必要
- 公開鍵（subjectPublicKeyInfo）：より柔軟、同じ鍵で証明書更新を許可、鍵パラメータとアルゴリズムコンテキストへのアクセスを提供
- ハッシュ：便利で固定長だがコンテキスト情報が不足

柔軟性とセキュリティコンテキストのバランスのため、subjectPublicKeyInfoピンニングを優先します。

### ピン管理のベストプラクティス

#### ピン追加タイミング
Trust On First Use（TOFU）ではなく、開発時にピンを追加（プリロード）します。帯域外のプリロードにより、攻撃者がピンを汚染することを防ぎます。

#### バックアップ戦略
証明書更新中のアプリケーション停止を防ぐため、常にバックアップピン（中間CAまたは代替証明書）を含めます。

#### 更新メカニズム
アプリの再デプロイを必要としない安全なピン更新方法を計画します。認証されたチャネルでのリモート設定を検討します。

#### 失敗処理
ユーザーにピン検証失敗のバイパスを決して許可しません。失敗をクライアント側でログに記録しますが、ピンの不一致時に接続を終了します。

### 企業環境の考慮事項

データ損失防止の一環として傍受プロキシを使用する組織の場合：
- 傍受プロキシを自動的に許可リストに追加しません
- 明示的なリスク受容承認後のみ、プロキシ公開鍵をピンセットに追加
- 企業プロキシを、エンドツーエンドセキュリティを依然として破る「良い悪者」として扱います

### テストと検証

OWASPモバイルセキュリティテストガイドのネットワーク通信ガイドラインを使用してピンニング実装を徹底的にテスト：
- ピン検証が正しく行われることを検証
- 証明書ローテーションシナリオをテスト
- 失敗処理パスを検証
- バックアップピンが適切に機能することを確認

### 運用上の考慮事項

#### 証明書ライフサイクル管理
- バックエンドチームと証明書ローテーションスケジュールを調整
- 証明書有効期限に先立ってピン更新を計画
- 証明書有効期間を監視
- ピン有効期限が近づいていることをアラート実装

#### リスク評価
ピンニングは適切に管理されない場合、アプリケーション停止の運用リスクを生じることを理解します。セキュリティの利点は、特定の脅威モデルの可用性リスクを上回る必要があります。

### 避けるべき一般的な実装エラー

- 検証済みライブラリの代わりにカスタムTLSまたはピンニング実装
- バックアップ戦略なしのピンニング
- ピン失敗のユーザーバイパスを許可
- 証明書ローテーションシナリオの不十分なテスト
- 拡張された信頼の影響を理解せずにルートCAをピンニング

### まとめ

証明書と公開鍵ピンニングは、洗練されたMITM攻撃に対する追加保護を提供できますが、重大な運用の複雑さと可用性リスクをもたらします。ほとんどのアプリケーションは、ピンニングを実装するのではなく、標準的な証明書検証に依存すべきです。ピンニングが必要な場合、プラットフォームネイティブソリューションまたは確立されたライブラリを使用し、包括的なバックアップ戦略を実装し、証明書ローテーションを含むすべてのシナリオを徹底的にテストします。
