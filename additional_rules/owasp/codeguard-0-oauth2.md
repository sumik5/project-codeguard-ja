---
description: OAuth 2.0セキュリティのベストプラクティス
languages:
- c
- go
- java
- javascript
- php
- python
- ruby
- typescript
- yaml
alwaysApply: false
---

## OAuth 2.0セキュリティガイドライン

安全なOAuth 2.0認可フローを実装し、一般的な攻撃から保護するための重要なセキュリティプラクティス。

### 基本事項

トークン流出を可能にするオープンリダイレクターを防止：
- クライアントと認可サーバーは、クエリパラメータから取得した任意のURIにユーザーのブラウザを転送するURLを公開してはいけません
- クライアント登録時のリダイレクトURI検証には正確な文字列マッチングを使用

適切なCSRF保護を使用：
- 認可サーバーがPKCEをサポートする場合、クライアントはPKCEのCSRF保護に依存できます
- OpenID Connectフローでは、「nonce」パラメータがCSRF保護を提供
- それ以外の場合、ユーザーエージェントに安全にバインドされた「state」パラメータでワンタイムCSRFトークンを使用

複数認可サーバー環境でのミックスアップ攻撃を防止：
- 複数の認可サーバーとやり取りする場合、対策として発行者「iss」パラメータを使用
- または、異なる認可およびトークンエンドポイントを識別するため個別のリダイレクトURIを使用
- 認可サーバーは、ユーザー認証情報を含むリクエストを誤って転送しないようにする必要があります

### PKCE - Proof Key for Code Exchange

PKCEは、特にパブリッククライアントに対する認可コード傍受攻撃を緩和します：

- 認可レスポンスへの認可コード注入（リプレイ）を防ぐためPKCEフローを使用
- 認可リクエストで検証子を公開しないPKCEコードチャレンジメソッドを使用
- 平文の代わりにS256をコードチャレンジメソッドとして使用
- 認可サーバーはPKCEをサポートし、トークンエンドポイントで正しい「code_verifier」使用を強制する必要があります
- 認可リクエストに「code_challenge」が存在する場合のみ「code_verifier」を受け入れることで、PKCEダウングレード攻撃を防ぎます

### 認可コード対Implicit Grant

Implicit GrantよりAuthorization Code Grantを優先：
- Implicitフローの代わりにレスポンスタイプ「code」（認可コードグラント）または「code id_token」を使用
- これにより、認可サーバーがリプレイ試行を検出でき、攻撃面が減少します
- アクセストークンはURLに公開されず、送信者制約が可能です

### トークンリプレイ防止

送信者制約メカニズムを実装：
- OAuth 2.0のMutual TLSまたはOAuth Demonstration of Proof of Possession（DPoP）を使用してトークンリプレイを防止
- リフレッシュトークンローテーションを実装するか、リフレッシュトークンが送信者制約されていることを確認

### アクセストークン権限制限

最小権限の原則を適用：
- トークン権限を特定のアプリケーションまたはユースケースに必要な最小限に制限
- アクセストークンを特定のリソースサーバーに関連付けることで対象者制限を実装
- リソースサーバーはトークンが自分たちの使用を意図していることを検証する必要があります
- 「scope」および「authorization_details」パラメータを使用して、トークンを特定のリソースとアクションに制限
- 「scope」および「resource」パラメータを使用して、意図されたリソースサーバーを決定

### 安全でないグラントタイプを避ける

リソースオーナーパスワード認証情報グラントを決して使用しない：
- このグラントタイプはリソースオーナー認証情報をクライアントに安全でなく公開
- アプリケーションの攻撃面を増加

### クライアント認証

強力な認証方式を使用：
- 可能な限りクライアント認証を実装
- mTLSや「private_key_jwt」（OpenID Connect）などの非対称（公開鍵ベース）方式を優先
- 非対称方式により、認可サーバー上に機密対称鍵を保存する必要がなくなります
- このアプローチは様々な攻撃に対してより堅牢です

### 追加のセキュリティ制御

機密クレームを保護し、安全な通信を強制：
- 認可サーバーは、クライアントが「client_id」または「sub」値に影響を与えることを許可してはいけません
- クライアントが本物のリソースオーナーデータと混同される可能性のあるクレームを制御することを防ぎます
- すべての通信にエンドツーエンドTLSを使用
- 暗号化されていないネットワーク接続を介して認可レスポンスを決して送信しません
- ループバックインターフェースリダイレクションを使用するネイティブクライアントを除き、「http」スキームを使用するリダイレクトURIを禁止

### 実装まとめ

安全なOAuth 2.0実装には以下が必要です：
- すべてのパブリッククライアントにPKCE実装
- stateパラメータまたはnonceによる適切なCSRF保護
- Implicit GrantよりAuthorization Code Grantの優先
- トークン送信者制約メカニズム（mTLSまたはDPoP）
- 厳格な権限制限と対象者検証
- 非対称方式を使用した強力なクライアント認証
- 安全でないグラントタイプの排除
- 包括的なTLS強制とリダイレクトURI検証

これらのプラクティスに従うことで、OAuth 2.0の柔軟性とセキュリティの利点を維持しながら、認可コード傍受、トークンリプレイ、権限昇格、ミックスアップ攻撃に対する堅牢な保護を保証します。
