---
description: REST APIセキュリティガイドライン
languages:
- c
- go
- java
- javascript
- php
- python
- ruby
- typescript
- xml
- yaml
alwaysApply: false
---

## REST APIセキュリティガイドライン

トランスポートセキュリティ、認証、入力検証、適切なエラー処理をカバーする、安全なRESTful Webサービス開発のための必須セキュリティプラクティス。

### REST APIの基本セキュリティ原則

REST APIはステートレスです。各リクエストには処理に必要なすべての情報が含まれている必要があります。状態はリソース状態を指し、セッション状態ではありません。クライアント状態をバックエンドに渡すことは避けてください。これはリプレイおよびなりすまし攻撃のベクトルを作成します。

各RESTエンドポイントは、特定のリソースに対する要求された操作の認可を独立して検証する必要があります。

### HTTPS要件

安全なRESTサービスは、以下を保護するためにHTTPSエンドポイントのみを提供する必要があります:
- 認証クレデンシャル（パスワード、APIキー、JSON Web Token）
- データの整合性と機密性
- サービスのクライアント認証

高度に特権的なWebサービスには、相互認証されたクライアント側証明書を検討してください。

### アクセス制御

非公開のRESTサービスは、各APIエンドポイントでアクセス制御を実行する必要があります:
- レイテンシを最小限に抑えるため、RESTエンドポイントでローカルにアクセス制御の決定を行う
- アクセストークンを発行する集中型アイデンティティプロバイダー（IdP）をユーザー認証に使用
- 分散サービス間でのグローバルセッション状態に依存しない

### JWTセキュリティ

セキュリティトークンにJSON Web Tokenを使用する場合:

必須要件:
- JWTが署名またはMACによって整合性が保護されていることを確認
- `{"alg":"none"}`の安全でないJWTを許可しない
- 整合性保護にはMACよりも署名を優先
- JWTヘッダー情報ではなく、ローカル設定に基づいてJWT整合性を検証

標準クレームの検証:
- `iss`（発行者）: 信頼できる発行者と署名鍵の所有権を検証
- `aud`（オーディエンス）: 依拠当事者がターゲットオーディエンスに含まれることを確認
- `exp`（有効期限）: 現在時刻がトークン有効期限前であることを検証
- `nbf`（開始時刻）: 現在時刻がトークン有効性開始後であることを検証

トークン失効:
- 明示的なセッション終了のためのJWT拒否リストを実装
- 自然な有効期限まで失効したJWTのハッシュを拒否リストに送信

### APIキー

アクセス制御が必要な公開RESTサービスの場合:
- 保護されたエンドポイントへのすべてのリクエストにAPIキーが必要
- レート制限違反には`429 Too Many Requests`を返す
- 利用規約違反のAPIキーを失効
- 機密性の高いリソースや高価値のリソースにはAPIキーのみに依存しない

### HTTPメソッド制限

- 許可されたHTTPメソッドの許可リスト（GET、POST、PUT、DELETE）を適用
- 許可されていないメソッドを`405 Method not allowed`で拒否
- リソースに対する特定のHTTPメソッドの呼び出し者認可を検証
- Java EE HTTPバーブタンパリング脆弱性には特に注意

### 入力検証

入力パラメータやオブジェクトを決して信頼しない:
- 入力の長さ、範囲、形式、タイプを検証
- 暗黙的な検証に強い型（数値、ブール値、日付）を使用
- 正規表現で文字列入力を制約
- 予期しないまたは不正なコンテンツを拒否
- 適切なリクエストサイズ制限を定義し、`413 Request Entity Too Large`を返す
- 攻撃検出のために入力検証失敗をログ記録
- XXEおよび類似の攻撃に耐性のある安全なパーサーを使用

### コンテンツタイプ検証

リクエスト検証:
- 予期しないまたは欠落しているContent-Typeヘッダーを持つリクエストを拒否（`406 Unacceptable`または`415 Unsupported Media Type`）
- Content-Length: 0のリクエストに対してのみContent-Typeの欠落を許可
- フレームワーク設定でサポートされるコンテンツタイプを明示的に定義
- XXE攻撃に対するXMLパーサーの強化を確保

レスポンスセキュリティ:
- AcceptヘッダーをContent-Typeレスポンスヘッダーに直接コピーしない
- サポートされていないAcceptヘッダーを持つリクエストを拒否（`406 Not Acceptable`）
- レスポンスボディコンテンツに一致する意図されたコンテンツタイプヘッダーを送信

### 管理エンドポイント

- インターネット経由で管理エンドポイントを公開しない
- インターネットアクセス可能な場合は強力な認証（多要素）が必要
- 異なるHTTPポート、ホスト、またはネットワークインターフェースを使用
- ファイアウォールルールまたはアクセス制御リストでアクセスを制限

### エラー処理

- 一般的なエラーメッセージで応答
- クライアントに技術的な詳細（コールスタック、内部ヒント）を決して明らかにしない
- 攻撃者を助けるシステム情報の公開を避ける

### 監査ログ

- セキュリティ関連イベントの前後に監査ログを書き込む
- 攻撃検出のためにトークン検証エラーをログ記録
- ログインジェクション攻撃を防ぐためにログデータをサニタイズ

### セキュリティヘッダー

すべてのAPIレスポンスにこれらのヘッダーを含める:

必須ヘッダー:
- `Cache-Control: no-store`: 機密情報のキャッシングを防止
- `Content-Security-Policy: frame-ancestors 'none'`: クリックジャッキングを防止
- `Content-Type`: MIMEスニッフィングを防ぐために正しいコンテンツタイプを指定
- `Strict-Transport-Security`: HTTPS専用アクセスを強制
- `X-Content-Type-Options: nosniff`: MIMEタイプの混乱を防止
- `X-Frame-Options: DENY`: 追加のクリックジャッキング保護

### CORS設定

- クロスドメイン呼び出しが不要な場合はCORSヘッダーを無効化
- 許可されたオリジンを設定する際は可能な限り具体的にする
- 本番環境でワイルドカードオリジンを避ける

### 機密情報の保護

URLに機密データを決して含めない:
- POST/PUTの機密データにはリクエストボディまたはヘッダーを使用
- GETリクエストの機密データにはHTTPヘッダーを使用
- パスワード、トークン、またはAPIキーにはクエリパラメータを避ける
- URLはWebサーバー、プロキシ、ブラウザによってログ記録される可能性がある

### HTTPステータスコード

意味的に適切なステータスコードを使用:
- `200 OK`: 成功した操作
- `201 Created`: Locationヘッダーを伴うリソース作成
- `400 Bad Request`: 不正な形式のリクエスト
- `401 Unauthorized`: 認証が必要
- `403 Forbidden`: 認可失敗
- `404 Not Found`: リソースが見つからない
- `405 Method Not Allowed`: HTTPメソッドがサポートされていない
- `406 Not Acceptable`: サポートされていないAcceptヘッダー
- `413 Payload Too Large`: リクエストサイズが超過
- `415 Unsupported Media Type`: サポートされていないContent-Type
- `429 Too Many Requests`: レート制限がトリガー
- `500 Internal Server Error`: 一般的なサーバーエラー（詳細なし）

### 実装まとめ

安全なREST API開発には以下が必要:
- 適切な証明書検証を伴うHTTPS専用エンドポイント
- エンドポイントごとの認可を持つステートレス設計
- 適切な検証と失効を伴う安全なJWT処理
- 包括的な入力検証とコンテンツタイプの強制
- 強力な認証を伴う保護された管理インターフェース
- 情報漏洩のない一般的なエラーレスポンス
- インジェクション防止を伴う完全な監査ログ
- 多層防御のための適切なセキュリティヘッダー
- 慎重なCORS設定と機密データの取り扱い
- 適切なクライアント動作のための意味的に正しいHTTPステータスコード
