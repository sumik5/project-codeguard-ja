---
description: パスワード保存セキュリティ
languages:
- c
- go
- java
- javascript
- php
- python
- ruby
- typescript
alwaysApply: false
---

## パスワード保存セキュリティガイドライン

オフライン攻撃から保護するため、最新のハッシュアルゴリズムを使用してパスワードを安全に保存するための重要なプラクティス。

### 基本原則

パスワードはハッシュ化する必要があり、暗号化してはいけません。ハッシュ化は一方向関数であり、データベースが侵害された場合でも元のパスワードの取得を防ぎます。暗号化は可逆的であり、元のパスワードを回復する必要がある稀なエッジケースでのみ使用すべきです。

最新のハッシュアルゴリズムと適切な設定で保存された強力なパスワードは、攻撃者にとって事実上解読不可能であるべきです。

推奨事項の要約：

- **最小構成として19 MiBのメモリ、反復回数2、並列度1で[Argon2id](#argon2id)を使用します。**
- **[Argon2id](#argon2id)が利用できない場合、最小CPU/メモリコストパラメータ(2^17)、最小ブロックサイズ8（1024バイト）、並列化パラメータ1で[scrypt](#scrypt)を使用します。**
- **[bcrypt](#bcrypt)を使用するレガシーシステムの場合、ワークファクター10以上、パスワード制限72バイトで使用します。**
- **FIPS-140準拠が必要な場合、ワークファクター600,000以上で[PBKDF2](#pbkdf2)を使用し、内部ハッシュ関数をHMAC-SHA-256に設定します。**
- **追加の多層防御を提供するため[pepper](#peppering)の使用を検討します（ただし単独では追加のセキュリティ特性を提供しません）。**

### 推奨アルゴリズムとパラメータ

以下の優先順位でこれらのアルゴリズムを使用します：

#### Argon2id（推奨）
Argon2idは2015年のPassword Hashing Competitionの優勝者であり、サイドチャネル攻撃とGPUベースの攻撃に対するバランスの取れた耐性を提供します。

設定オプション（1つ選択）：
- m=47104（46 MiB）、t=1、p=1
- m=19456（19 MiB）、t=2、p=1
- m=12288（12 MiB）、t=3、p=1
- m=9216（9 MiB）、t=4、p=1
- m=7168（7 MiB）、t=5、p=1

すべての設定は、CPU/RAMのトレードオフが異なるだけで、同等のセキュリティを提供します。

#### scrypt（Argon2idが利用できない場合）
設定オプション（1つ選択）：
- N=2^17（128 MiB）、r=8（1024バイト）、p=1
- N=2^16（64 MiB）、r=8（1024バイト）、p=2
- N=2^15（32 MiB）、r=8（1024バイト）、p=3
- N=2^14（16 MiB）、r=8（1024バイト）、p=5
- N=2^13（8 MiB）、r=8（1024バイト）、p=10

#### bcrypt（レガシーシステムのみ）
ワークファクター10以上を使用します。ほとんどの実装で最大パスワード長は72バイトです。

#### PBKDF2（FIPS-140準拠が必要）
- PBKDF2-HMAC-SHA1: 1,300,000反復
- PBKDF2-HMAC-SHA256: 600,000反復
- PBKDF2-HMAC-SHA512: 210,000反復

### ソルト

最新のハッシュアルゴリズム（Argon2id、bcrypt、scrypt、PBKDF2）は自動的にソルトを処理します。ソルトは以下である必要があります：
- すべてのパスワードで一意
- 暗号学的に安全な乱数生成器を使用して生成
- ハッシュと一緒に保存

最新のアルゴリズムを使用する場合、手動でソルトを実装しないでください。

### ペッパー（オプションの多層防御）

ペッパーは、パスワードごとに一意なソルトとは異なり、保存されたパスワード間で共有される秘密値です。ペッパーは、データベースが侵害されたがアプリケーションサーバーが安全なままである場合に追加の保護を提供します。

ペッパーの要件：
- パスワードデータベースとは別にペッパーを保存
- セキュアなストレージを使用（シークレットボルト、HSM）
- 暗号学的に強力な方法を使用してセキュアに生成
- ペッパーの変更にはすべてのユーザーがパスワードをリセットする必要があります

実装戦略：
- プレハッシュ：ハッシュ化前にパスワードにペッパーを追加
- ポストハッシュ：ペッパーをキーとしてパスワードハッシュをHMAC化

### ワークファクター調整

ワークファクターを調整してセキュリティとパフォーマンスのバランスを取ります：
- ハッシュ計算に1秒未満を目標とする
- ハードウェアが向上するにつれてワークファクターを増やす
- 特定のサーバーハードウェアでテストする
- より高いワークファクターは、正規の認証と攻撃者の解読の両方を遅くします

### レガシーハッシュのアップグレード

弱いアルゴリズム（MD5、SHA-1）を使用しているアプリケーションの場合：

方法1：パスワードリセットを強制
- 非アクティブユーザーの古いハッシュを期限切れにする
- 次回ログイン時にパスワードリセットを要求
- より安全だがユーザーフレンドリーではない

方法2：レイヤーハッシング
- 既存のハッシュをセキュアなアルゴリズムへの入力として使用
- 例：`bcrypt(md5($password))`
- ユーザーが次回認証する際に直接ハッシング化にアップグレード
- PHC文字列形式を使用してアルゴリズムとパラメータを保存

### bcryptプレハッシュの考慮事項

bcryptでプレハッシュが必要な場合：
- `bcrypt(base64(hmac-sha384(data:$password, key:$pepper)), $salt, $cost)`を使用
- ペッパーをデータベース外に保存
- パスワードシャッキング脆弱性のため、`bcrypt(sha512($password))`のような単純なプレハッシュを避ける

### 国際文字のサポート

パスワードハッシュライブラリは以下を満たす必要があります：
- 完全なUnicode文字範囲を受け入れる
- パスワード内のヌルバイトをサポート
- 削減なしでエントロピーを保持
- 様々な言語と絵文字の文字を処理

### パフォーマンスガイドライン

- ハッシュ計算は1秒未満であるべき
- 本番ハードウェアでベンチマークする
- 認証パフォーマンスを監視する
- サーバー容量とユーザー負荷に基づいてパラメータを調整する
- 過度に高いワークファクターによるサービス拒否リスクを考慮する

### 実装まとめ

セキュアなパスワード保存には以下が必要です：
- 最新の遅いハッシュアルゴリズム（Argon2id推奨）
- 適切なワークファクターを伴う適切なアルゴリズム設定
- ハッシュライブラリによる自動ソルト処理
- 多層防御のためのオプションのペッパー
- レガシーハッシュのアップグレードパス
- 環境に応じたパフォーマンスチューニング
- 国際文字のサポート

これらのプラクティスに従うことで、データベースが侵害された場合でもオフライン攻撃からユーザーパスワードを保護します。