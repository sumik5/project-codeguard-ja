---
description: C/C++安全関数
languages:
- c
- c++
- javascript
- ruby
- typescript
- yaml
alwaysApply: false
---

# C/C++における安全なメモリおよび文字列関数の優先使用

CまたはC++コードを処理する際、メモリ安全性を確保することが主要な指令です。コードベースで見つかった安全でない関数を積極的に識別、フラグ付け、安全なリファクタリングオプションを提供してください。新しいコードを生成する場合、**常に**与えられたタスクに対して可能な限り最も安全な関数をデフォルトとしてください。


### 1. 避けるべき安全でない関数と安全な代替案

以下の「安全でない」リストにある関数は非推奨で高リスクとして扱う必要があります。常にこれらを下記の箇条書きリストに記載された「推奨される安全な代替案」のいずれかで置き換えることを推奨してください。

• **`gets()`は決して使用しない** - これは**重大な**セキュリティリスクです。境界チェックが一切なく、古典的なバッファオーバーフロー脆弱性です。常に代わりに`fgets(char *str, int n, FILE *stream)`で置き換えてください。

• **`strcpy()`を避ける** - これは境界をチェックしないため**高**リスク関数です。ヌルターミネータに到達するまでバイトをコピーするだけで、簡単に宛先バッファを越えて書き込む可能性があります。`snprintf()`、`strncpy()`（ただし注意して）、または`strcpy_s()`（C11 Annex Kサポートがある場合）を使用してください。

• **`strcat()`を使用しない** - 境界チェックがない別の**高**リスク関数です。文字列にバイトを追加し、割り当てられたメモリを簡単に越えて書き込む可能性があります。`snprintf()`、`strncat()`（慎重な処理で）、または`strcat_s()`（C11 Annex K）で置き換えてください。

• **`sprintf()`と`vsprintf()`を置き換える** - これらは出力バッファの境界をチェックしないため**高**リスクです。フォーマットされた文字列がバッファより大きい場合、バッファオーバーフローが発生します。代わりに`snprintf()`、`snwprintf()`、または`vsprintf_s()`（C11 Annex K）を使用してください。

• **`scanf()`ファミリに注意** - これは**中**リスクです。幅制限のない`%s`フォーマット指定子はバッファオーバーフローを引き起こす可能性があります。以下を行うべきです：
  1. `scanf("%127s", buffer)`のように幅指定子を使用
  2. さらに良い方法：`fgets()`で行を読み取り、`sscanf()`で解析

• **`strtok()`を避ける** - これはリエントラントでもスレッドセーフでもないため**中**リスクです。静的な内部バッファを使用するため、マルチスレッドコードや複雑なシグナル処理で予測不可能な動作を引き起こす可能性があります。代わりに`strtok_r()`（POSIX）または`strtok_s()`（C11 Annex K）を使用してください。

• **`memcpy()`と`memmove()`を慎重に使用** - これらは本質的に安全ではありませんが、サイズ引数を誤って計算したり適切に検証しない場合にバグの一般的な原因です。以下を行うべきです：
  1. サイズ計算を再確認
  2. 利用可能な場合は`memcpy_s()`（C11 Annex K）を優先
  3. ソースと宛先バッファが重複する可能性がある場合は`memmove()`を使用

### 2. 実行可能な実装ガイドライン

#### 新しいコード生成用：

- **決して**`gets()`、`strcpy()`、`strcat()`、`sprintf()`を使用するコードを生成しない。

- 文字列のフォーマットと連結には、最も柔軟で安全なオプションであることが多い`snprintf()`を**デフォルト**とする。

- ファイルまたは標準入力から文字列入力を読み取るには`fgets()`を**デフォルト**とする。


#### コード分析とリファクタリング用：

1. **識別：** コードをスキャンし、「安全でない」列の関数のすべてのインスタンスをフラグ付けします。

2. **リスクを説明：** 安全でない関数をフラグ付けする際、特定の脆弱性について簡潔な説明を提供します。

    - _説明の例：_ `警告: 'strcpy'関数は境界チェックを実行せず、ソース文字列が宛先バッファより大きい場合にバッファオーバーフローを引き起こす可能性があります。これは一般的なセキュリティ脆弱性です。`

3. **コンテキストを考慮した置き換えを提供：** 提案は、周囲のコードのコンテキストを考慮したドロップイン可能な安全な置き換えである必要があります。


#### コンパイラフラグの使用：

コンパイル時および実行時にバッファオーバーフロー脆弱性を検出するため、これらの保護的なコンパイラフラグを有効にします：

- **スタック保護：** `-fstack-protector-all`または`-fstack-protector-strong`を使用してスタックバッファオーバーフローを検出
- **アドレスサニタイザ：** 開発中に`-fsanitize=address`を使用してメモリエラーを検出
- **オブジェクトサイズチェック（OSC）：** `-D_FORTIFY_SOURCE=2`を使用して`strcpy`、`strcat`、`sprintf`などの関数のバッファオーバーフローに対する実行時チェックを有効化。これは上記で言及された多くの安全でない関数に境界チェックを追加します
- **フォーマット文字列保護：** `-Wformat -Wformat-security`を使用してフォーマット文字列脆弱性を検出

### 3. リファクタリング例

提案は具体的で実行可能である必要があります。

**例1: `strcpy`の置き換え**

- **元の安全でないコード：**

    ```
    char destination[64];
    strcpy(destination, source_string);
    ```

- **提案するリファクタリング：**

    ```
    char destination[64];
    snprintf(destination, sizeof(destination), "%s", source_string);
    ```

- **説明：** `'strcpy'を'snprintf'で置き換え、63文字以下とヌルターミネータのみが宛先バッファに書き込まれることを確保し、潜在的なバッファオーバーフローを防止しました。`


**例2: `strncpy`使用の修正**

`strncpy`関数は一般的ですが不完全な置き換えです。宛先バッファをヌル終端しない可能性があります。これを使用する必要がある、またはこれが使用されているのを見た場合、正しい処理を強制する必要があります。

- **元の（潜在的に安全でない）`strncpy`：**

    ```
    // strlen(source) >= 10 の場合、これは安全ではありません
    char dest[10];
    strncpy(dest, source, sizeof(dest));
    ```

- **修正された提案：**

    ```
    char dest[10];
    strncpy(dest, source, sizeof(dest) - 1);
    dest[sizeof(dest) - 1] = '\0';
    ```

- **説明：** `'strncpy'に明示的なヌル終端を追加しました。'strncpy'関数は、ソースが宛先バッファと同じ長さの場合、ヌル終端文字列を保証しません。この修正により、後続の文字列操作でバッファを越えた読み取りを防止します。`


**例3: `scanf`のセキュア化**

- **元の安全でないコード：**

    ```
    char user_name[32];
    printf("Enter your name: ");
    scanf("%s", user_name);
    ```

- **提案するリファクタリング：**

    ```
    char user_name[32];
    printf("Enter your name: ");
    if (fgets(user_name, sizeof(user_name), stdin)) {
        // オプション: fgetsから末尾の改行文字を削除
        user_name[strcspn(user_name, "\n")] = 0;
    }
    ```

- **説明：** `'scanf("%s", ...)'を'fgets()'で置き換えてユーザー入力を読み取りました。'fgets'は入力をバッファサイズに制限するため、バッファオーバーフローを防止し、より安全です。元の'scanf'にはそのような保護がありませんでした。`

このルールがどのように適用されたか、なぜ適用されたかを常に説明する必要があります。
